% Analyzes the results of a parameter test for pools with only +1 encoding
% See NEF_demo/parameter_testing_1side.py
% Generates decoding weights and saves them to a file for use in further experiments.
clc; clear all;

%select which experiment to import
expNum = 0;

params_path = ['../data/parameters/' num2str(expNum) '.txt']
fid = fopen(params_path); % read in parameters
p = textscan(fid,'%s %f');
fclose(fid);
params = containers.Map(p{1},p{2});
n = params('n');                % n*n = number of neurons that will recieve input
sparsity = params('sparsity');  % sparsity pattern of network
N = params('N');                % N*N = total number of neurons in network (N=n*sparsity)
n_chips = params('n_chips');    % number of chips
N_STIM = params('N_STIM');      % number of stimulus levels within valid input range
maxRange = params('max_range'); % input rate corresponding to max scalar input
maxLimit = params('max_limit'); % input rate corresponding to max input over valid range
duration = params('duration');  % duration of each stimulus
FPGA_MAX = params('FPGA_PAD');  % maximum weight of FPGA
maxIn = maxLimit/maxRange;
a=1/(maxIn-1);
values = linspace(0,maxIn,N_STIM);  % input scalar values
overVals = values(values>1);
outputValues = values; 
outputValues(values>1)=(-a/2*overVals.^2 + (a+1)*overVals - a/2); % round off values to prevent out of bounds decoding errors

xvals = maxRange*outputValues;        % input values converted to firing rates - what the neurons actually see

t_start = linspace(0,duration*(N_STIM-1),N_STIM);

iodd = 1:2:N_STIM; %odd index selector - for testing weights
ieven = 2:2:N_STIM; %even index selector - for training weights
xTrain = xvals(ieven)';
xTest = xvals(iodd)'; 

FPGA_Q_LEVELS=64;
FPGA_RES = FPGA_MAX/FPGA_Q_LEVELS;

%calculated parameters (from user set params above)
xLoc = sparsity/2:sparsity:N;
diffuseTapX = repmat(xLoc,1,8);
diffuseTapY = reshape(repmat(xLoc,8,1),1,[]);
xSize = N;
ySize = N;

%% Read .spk file
A_orig = zeros(N_STIM,N^2); % for raw spike data
fname = ['../data/tuning/' int2str(expNum) '.spk'];
[outDat, coord, ts] = readNGBinSparse_reorder(fname, xSize, ySize,[1]);
spk = outDat{1};

for k = 1:N_STIM
    idx1 = 1000*(t_start(k) + (duration*.15)); % discard initial part of trial
    idx2 = 1000*(t_start(k) + duration);     
    
    these_spk = spk(:,uint32(idx1):uint32(idx2)); % select spikes, typcasting to avoid warnings
    A_orig(k,:) = (sum(these_spk,2)/((idx2-idx1)/1000))';      %convert to mean firing rates
    
end

ATrain = A_orig(ieven,:); % for training weights
ATest = A_orig(iodd,:); % for testing weights

%% Remove neurons w/ x intercept outside of -1 to 1 and little response to stimulus
% use neurons w/o background firing rate (x intercepts in input range) and at least a small change in response from 0 stim to max stim
begin_rate = A_orig(1,:);
end_rate = A_orig(end,:);
master_slopes = end_rate-begin_rate;
% % TODO : read in list of encoding vectors to say which neuron is +1 or -1
pick = begin_rate<=40;  % select +1 neurons

%% Calculate Decode Weights
% calculate with svd technique
wSVD = zeros(N^2,1);
[wSVD(pick),S1Pos] = calculate_decoding_svd(ATrain(:,pick), xTrain);
[wSVD_clean,numCulledPos] = cleanWeights(wSVD, FPGA_MAX, FPGA_RES);

% calculate with regularization
wReg = zeros(N^2,1);
wReg(pick) = calculate_decoding_reg(ATrain(:,pick), xTrain,4000); % regularization of 700 recommended by Steve
[wReg_clean,numCulledPos] = cleanWeights(wReg, FPGA_MAX, FPGA_RES);

% using convex solver to calculate decoding weights
wcvx = zeros(N^2,1);
[wcvx(pick) cvx_success]=calculate_decoding_cvx(ATrain(:,pick),xTrain,FPGA_MAX,0);
[wcvx_clean,numCulledPos] = cleanWeights(wcvx, FPGA_MAX, FPGA_RES);

%% Perform Decode and plot
% Decode positions with data not used in training
x_hat_svd = ATest*wSVD; % estimate x using all weights
x_hat_reg = ATest*wReg; % estimate x using regularized weights
x_hat_cvx = ATest*wcvx; % estimate x using cvx weights

% Plot Decoder Output of original weights %
figure(1); clf; hold on; grid off;
plot(xTest,x_hat_svd,'r.','MarkerSize',16); hold on; grid on
plot(xTest,x_hat_reg,'g.','MarkerSize',16);
plot(xTest,x_hat_cvx,'b:.','MarkerSize',16);
plot(xTest,xTest,'k','LineWidth',1);
axis tight;
hXLabel = xlabel('Input');
hYLabel = ylabel('Output');
hLegend = legend('SVD','Regularization','CVX','location','best');
hTitle  = title('Decoder Output with Original Weights');
set( gca                       , ...
    'FontName'   , 'Arial' );
set([hTitle, hXLabel, hYLabel], ...
    'FontName'   , 'Arial');
set([hLegend, gca]             , ...
    'FontSize'   , 14           );
set([hXLabel, hYLabel]  , ...
    'FontSize'   , 16          );
set( hTitle                    , ...
    'FontSize'   , 16          , ...
    'FontWeight' , 'bold'      );
set(gca, ...
  'Box'         , 'off'     , ...
  'TickDir'     , 'out'     , ...
  'TickLength'  , [.02 .02] , ...
  'XMinorTick'  , 'off'      , ...
  'YMinorTick'  , 'off'      , ...
  'YGrid'       , 'on'      , ...
  'XColor'      , [.3 .3 .3], ...
  'YColor'      , [.3 .3 .3], ...
  'LineWidth'   , 1         );

% Plot Decoder Output of rounded weights %
x_hat_svd_clean = ATest*wSVD_clean; 
x_hat_reg_clean = ATest*wReg_clean; 
x_hat_cvx_clean = ATest*wcvx_clean; 
figure(2); clf;
plot(xTest,x_hat_svd_clean,'r.','MarkerSize',16); hold on; grid on
plot(xTest,x_hat_reg_clean,'g.','MarkerSize',16);
plot(xTest,x_hat_cvx_clean,'b:.','MarkerSize',16,'LineWidth',2);
plot(xTest,xTest,'k','LineWidth',1);
axis tight;
hXLabel = xlabel('Input');
hYLabel = ylabel('Output');
hLegend = legend('SVD','Regularization','CVX','location','best');
hTitle  = title('Decoder Output with FPGA Implementable Weights');
set( gca                       , ...
    'FontName'   , 'Arial' );
set([hTitle, hXLabel, hYLabel], ...
    'FontName'   , 'Arial');
set([hLegend, gca]             , ...
    'FontSize'   , 14           );
set([hXLabel, hYLabel]  , ...
    'FontSize'   , 16          );
set( hTitle                    , ...
    'FontSize'   , 16          , ...
    'FontWeight' , 'bold'      );
set(gca, ...
  'Box'         , 'off'     , ...
  'TickDir'     , 'out'     , ...
  'TickLength'  , [.02 .02] , ...
  'XMinorTick'  , 'off'      , ...
  'YMinorTick'  , 'off'      , ...
  'YGrid'       , 'on'      , ...
  'XColor'      , [.3 .3 .3], ...
  'YColor'      , [.3 .3 .3], ...
  'LineWidth'   , 1         );

% % Plot decoder performance on training data - best possible performance
% xtrain_hat_svd = ATrain*wSVD; % estimate x using all weights
% xtrain_hat_reg = ATrain*wReg; % estimate x using regularized weights
% xtrain_hat_cvx = ATrain*wcvx; % estimate x using cvx weights
% figure(21); clf; hold on; grid off;
% plot(xTrain,xtrain_hat_svd,'r.','MarkerSize',16); hold on; grid on
% plot(xTrain,xtrain_hat_reg,'g.','MarkerSize',16);
% plot(xTrain,xtrain_hat_cvx,'b.','MarkerSize',16);
% plot(xvals,xvals,'k','LineWidth',1);
% hXLabel = xlabel('Input');
% hYLabel = ylabel('Output');
% hLegend = legend('SVD','Regularization','CVX','location','best');
% hTitle  = title('Decoder Output: with Original Weights - Training Data');
% set( gca                       , ...
%     'FontName'   , 'Arial' );
% set([hTitle, hXLabel, hYLabel], ...
%     'FontName'   , 'Arial');
% set([hLegend, gca]             , ...
%     'FontSize'   , 14           );
% set([hXLabel, hYLabel]  , ...
%     'FontSize'   , 16          );
% set( hTitle                    , ...
%     'FontSize'   , 16          , ...
%     'FontWeight' , 'bold'      );
% set(gca, ...
%   'Box'         , 'off'     , ...
%   'TickDir'     , 'out'     , ...
%   'TickLength'  , [.02 .02] , ...
%   'XMinorTick'  , 'off'      , ...
%   'YMinorTick'  , 'off'      , ...
%   'YGrid'       , 'on'      , ...
%   'XColor'      , [.3 .3 .3], ...
%   'YColor'      , [.3 .3 .3], ...
%   'LineWidth'   , 1         );

% % Plot Decoder Output of rounded weights - best possible performance with implementable weights
% xtrain_hat_svd_clean = ATrain*wSVD_clean; 
% xtrain_hat_reg_clean = ATrain*wReg_clean; 
% xtrain_hat_cvx_clean = ATrain*wcvx_clean; 
% figure(22); clf;
% plot(xTrain,xtrain_hat_svd_clean,'r.','MarkerSize',16); hold on; grid on
% plot(xTrain,xtrain_hat_reg_clean,'g.','MarkerSize',16);
% plot(xTrain,xtrain_hat_cvx_clean,'b.','MarkerSize',16);
% plot(xvals,xvals,'k','LineWidth',1);
% hXLabel = xlabel('Input Value');
% hYLabel = ylabel('Output Frequency');
% hLegend = legend('SVD','Regularization','CVX','location','best');
% hTitle  = title('Decoder Output: with FPGA Implementable Weights - Training Data');
% set( gca                       , ...
%     'FontName'   , 'Arial' );
% set([hTitle, hXLabel, hYLabel], ...
%     'FontName'   , 'Arial');
% set([hLegend, gca]             , ...
%     'FontSize'   , 14           );
% set([hXLabel, hYLabel]  , ...
%     'FontSize'   , 16          );
% set( hTitle                    , ...
%     'FontSize'   , 16          , ...
%     'FontWeight' , 'bold'      );
% set(gca, ...
%   'Box'         , 'off'     , ...
%   'TickDir'     , 'out'     , ...
%   'TickLength'  , [.02 .02] , ...
%   'XMinorTick'  , 'off'      , ...
%   'YMinorTick'  , 'off'      , ...
%   'YGrid'       , 'on'      , ...
%   'XColor'      , [.3 .3 .3], ...
%   'YColor'      , [.3 .3 .3], ...
%   'LineWidth'   , 1         );

%% Plot decoder error
% Plot Decoder Output of rounded weights
figure(3); clf;
plot(xTest,x_hat_cvx_clean - xTest,'b-o','MarkerSize',8,'LineWidth',2); hold on;
plot(xTest,zeros(length(xTest),1),'k','LineWidth',1);
hXLabel = xlabel('Input');
hYLabel = ylabel('Error');
hTitle  = title('Decoder Error with FPGA Implementable Weights');

set( gca                       , ...
    'FontName'   , 'Arial' );
set([hTitle, hXLabel, hYLabel], ...
    'FontName'   , 'Arial');
set([hXLabel, hYLabel]  , ...
    'FontSize'   , 16          );
set( hTitle                    , ...
    'FontSize'   , 16          , ...
    'FontWeight' , 'bold'      );

set(gca, ...
  'Box'         , 'off'     , ...
  'TickDir'     , 'out'     , ...
  'TickLength'  , [.02 .02] , ...
  'XMinorTick'  , 'off'      , ...
  'YMinorTick'  , 'off'      , ...
  'YGrid'       , 'on'      , ...
  'XColor'      , [.3 .3 .3], ...
  'YColor'      , [.3 .3 .3], ...
  'LineWidth'   , 1         );

%% Plot weights in sorted order
figure(4); clf; 
plot(sort(wSVD,'descend'),'r','LineWidth',2);  hold on; grid on;
plot(sort(wSVD_clean,'descend'),'r','LineWidth',1);
plot(sort(wReg,'descend'),'g','LineWidth',2);
plot(sort(wReg_clean,'descend'),'g','LineWidth',1);
plot(sort(wcvx,'descend'),'b','LineWidth',2);
plot(sort(wcvx_clean,'descend'),'b','LineWidth',1);
hYLabel = ylabel('Weight');
hTitle  = title('Sorted Weights');
hLegend = legend('SVD','SVD FPGA','Reg','Reg FPGA','CVX','CVX FPGA','location','best');
axis tight;
set( gca                       , ...
    'FontName'   , 'Arial' );
set([hTitle, hXLabel, hYLabel], ...
    'FontName'   , 'Arial');
set([hLegend, gca]             , ...
    'FontSize'   , 12           );
set([hXLabel, hYLabel]  , ...
    'FontSize'   , 16          );
set( hTitle                    , ...
    'FontSize'   , 16          , ...
    'FontWeight' , 'bold'      );

set(gca, ...
  'Box'         , 'off'     , ...
  'TickDir'     , 'out'     , ...
  'TickLength'  , [.02 .02] , ...
  'XMinorTick'  , 'off'      , ...
  'YMinorTick'  , 'off'      , ...
  'YGrid'       , 'on'      , ...
  'XColor'      , [.3 .3 .3], ...
  'YColor'      , [.3 .3 .3], ...
  'LineWidth'   , 1         );

%% image matrix of differente between firing rates @max and min stim 
% figure(5); clf;
% imagesc(reshape(master_slopes,N,N)')
% set(gca,'YDir','normal')
% hold on
% plot(1:64,N/2*ones(1,64),'r')
% plot(diffuseTapX,diffuseTapY,'ws','markersize',8,'linewidth',2)
% colorbar
% hXLabel = xlabel('X Coord');
% hYLabel = ylabel('Y Coord');
% axis square;
% hTitle  = title('Change in firing rate from min to max input');
% 
% set( gca                       , ...
%     'FontName'   , 'Arial' );
% set([hTitle, hXLabel, hYLabel], ...
%     'FontName'   , 'Arial');
% set([hXLabel, hYLabel]  , ...
%     'FontSize'   , 16          );
% set( hTitle                    , ...
%     'FontSize'   , 16          , ...
%     'FontWeight' , 'bold'      );
% 
% set(gca, ...
%   'Box'         , 'off'     , ...
%   'TickDir'     , 'out'     , ...
%   'TickLength'  , [.02 .02] , ...
%   'XMinorTick'  , 'off'      , ...
%   'YMinorTick'  , 'off'      , ...
%   'YGrid'       , 'off'      , ...
%   'XColor'      , [.3 .3 .3], ...
%   'YColor'      , [.3 .3 .3], ...
%   'YTick'       , 0:8:64, ...
%   'XTick'       , 0:8:64, ...
%   'LineWidth'   , 1         );

%% image of decode weights w/ diffuser tap points overlaid
figure(6); clf;  
w_xy = reshape(wSVD_clean,N,N)';
imagesc(w_xy);    hold on; 
set(gca,'YDir','normal')
plot(diffuseTapX,diffuseTapY,'ws','markersize',7)
colormap(jet);
colorbar;
axis square
hXLabel = xlabel('X Coord');
hYLabel = ylabel('Y Coord');
hTitle  = title(['Decode Weights (# Neurons - Pos: ' int2str(sum(wSVD_clean>0)) ')']);
set( gca                       , ...
    'FontName'   , 'Arial' );
set([hTitle, hXLabel, hYLabel], ...
    'FontName'   , 'Arial');
set([hLegend, gca]             , ...
    'FontSize'   , 8           );
set([hXLabel, hYLabel]  , ...
    'FontSize'   , 16          );
set( hTitle                    , ...
    'FontSize'   , 16          , ...
    'FontWeight' , 'bold'      );
set(gca, ...
  'Box'         , 'off'     , ...
  'TickDir'     , 'out'     , ...
  'TickLength'  , [.02 .02] , ...
  'XMinorTick'  , 'off'      , ...
  'YMinorTick'  , 'off'      , ...
  'YGrid'       , 'on'      , ...
  'XColor'      , [.3 .3 .3], ...
  'YColor'      , [.3 .3 .3], ...
  'YTick'       , 4:8:60, ...
  'XTick'       , 4:8:60, ...
  'LineWidth'   , 1         );

%% Plot FF Curves
figure(7); clf; set(gcf,'DefaultAxesColorOrder', colormap(jet(30)));
plot(xvals,A_orig(:,pick),'linewidth',.1); grid off; 
xlim([0 maxIn*maxRange]);
hYLabel = ylabel('Response Frequency');
hXLabel = xlabel('Input Frequency');
hTitle  = title('Tuning Curves of Neurons used for Decoding');
set( gca                       , ...
    'FontName'   , 'Arial' );
set([hTitle, hXLabel, hYLabel], ...
    'FontName'   , 'Arial');
set([hLegend, gca]             , ...
    'FontSize'   , 8           );
set([hXLabel, hYLabel]  , ...
    'FontSize'   , 16          );
set( hTitle                    , ...
    'FontSize'   , 16          , ...
    'FontWeight' , 'bold'      );
set(gca, ...
  'Box'         , 'off'     , ...
  'TickDir'     , 'out'     , ...
  'TickLength'  , [.02 .02] , ...
  'XMinorTick'  , 'off'      , ...
  'YMinorTick'  , 'off'      , ...
  'YGrid'       , 'on'      , ...
  'XColor'      , [.3 .3 .3], ...
  'YColor'      , [.3 .3 .3], ...
  'LineWidth'   , 1         );

figure(8); clf; %neurons with nonzero weighted tuning curves
plot(xvals,A_orig(:,wcvx_clean~=0));
nonneg=sum(wcvx_clean~=0);

hYLabel = ylabel('Response Frequency');
hXLabel = xlabel('Input Frequency');
hTitle  = title(['Tuning Curves: Non-zero Weighted Neurons (' num2str(nonneg) ')']);
xlim([0 maxIn*maxRange]);
set( gca                       , ...
    'FontName'   , 'Arial' );
set([hTitle, hXLabel, hYLabel], ...
    'FontName'   , 'Arial');
set([hLegend, gca]             , ...
    'FontSize'   , 8           );
set([hXLabel, hYLabel]  , ...
    'FontSize'   , 16          );
set( hTitle                    , ...
    'FontSize'   , 16          , ...
    'FontWeight' , 'bold'      );
set(gca, ...
  'Box'         , 'off'     , ...
  'TickDir'     , 'out'     , ...
  'TickLength'  , [.02 .02] , ...
  'XMinorTick'  , 'off'      , ...
  'YMinorTick'  , 'off'      , ...
  'YGrid'       , 'on'      , ...
  'XColor'      , [.3 .3 .3], ...
  'YColor'      , [.3 .3 .3], ...
  'LineWidth'   , 1         );

%%  Error Analysis
% % this section is for analyzing the relative errors between decoding methods   
errors = zeros(1,4);
errors(1) = mean((xTest/maxRange-x_hat_svd/maxRange).^2); % SVD Weights
errors(2) = mean((xTest/maxRange-x_hat_reg/maxRange).^2); % Reg Weights
errors(3) = mean((xTest/maxRange-x_hat_cvx/maxRange).^2); % CVX Weights
errors(4) = mean((xTest/maxRange-x_hat_cvx_clean/maxRange).^2);

figure(9); clf;
bar(errors)
set(gca,'XTickLabel',{'SVD','Reg','CVX','CVX clean'})
hYLabel = ylabel('Mean Square Error');

set( gca                       , ...
    'FontName'   , 'Arial' );
set([hTitle, hXLabel, hYLabel], ...
    'FontName'   , 'Arial');
set([hXLabel, hYLabel]  , ...
    'FontSize'   , 16          );
set( hTitle                    , ...
    'FontSize'   , 16          , ...
    'FontWeight' , 'bold'      );
set(gca, ...
  'Box'         , 'off'     , ...
  'TickDir'     , 'out'     , ...
  'TickLength'  , [.02 .02] , ...
  'XMinorTick'  , 'off'      , ...
  'YMinorTick'  , 'off'      , ...
  'YGrid'       , 'on'      , ...
  'XColor'      , [.3 .3 .3], ...
  'YColor'      , [.3 .3 .3], ...
  'LineWidth'   , 1         );

%% Save figures and data to file

print(figure(1),['./figures/exp' int2str(expNum) '_decode_raw_output'],'-dpng')
print(figure(2),['./figures/exp' int2str(expNum) '_decode_rounded_output'],'-dpng')
print(figure(3),['./figures/exp' int2str(expNum) '_decode_error'],'-dpng')
print(figure(4),['./figures/exp' int2str(expNum) '_dweights_sort'],'-dpng')
% print(figure(5),['./figures/exp' int2str(expNum) '_freq_diff_xy'],'-dpng')
print(figure(6),['./figures/exp' int2str(expNum) '_dweights_xy'],'-dpng')
print(figure(7),['./figures/exp' int2str(expNum) '_tuning_curves'],'-dpng')
print(figure(8),['./figures/exp' int2str(expNum) '_tuning_curves_nonzero_weighted'],'-dpng')
print(figure(9),['./figures/exp' int2str(expNum) '_error_comparison'],'-dpng')

%% Save data, Write weights to file for python code
svPath = '../data/D/';
wOut = wcvx_clean;
save([svPath  num2str(expNum) '_DWeights'],'wOut','-ascii', '-double')

% save(['./workspaces/' int2str(expNum) '_tuningdata'])
